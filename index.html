<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048游戏 - 修复版</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 700;
            color: #ffd166;
            text-shadow: 0 2px 10px rgba(255, 209, 102, 0.3);
        }
        
        .scores-container {
            display: flex;
            gap: 10px;
        }
        
        .score-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 6px;
            text-align: center;
            min-width: 100px;
            backdrop-filter: blur(10px);
        }
        
        .score-title {
            font-size: 0.9rem;
            color: #e6e6e6;
            margin-bottom: 5px;
        }
        
        .score-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }
        
        .game-intro {
            text-align: center;
            margin-bottom: 20px;
            color: #b8c2cc;
        }
        
        .game-container {
            position: relative;
            background: rgba(34, 40, 49, 0.8);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 10px;
            background: rgba(57, 62, 70, 0.6);
            border-radius: 6px;
            padding: 10px;
            position: relative;
        }
        
        .grid-cell {
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            background: rgba(238, 238, 238, 0.15);
            border-radius: 4px;
        }
        
        .tile-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
        }
        
        .tile {
            position: absolute;
            width: calc(25% - 10px);
            height: calc(25% - 10px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            border-radius: 4px;
            transition: all 0.12s ease-out;
            z-index: 10;
        }
        
        .tile-new {
            animation: appear 0.2s ease-out;
        }
        
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .tile-merged {
            animation: pop 0.2s ease-out;
            z-index: 20;
        }
        
        @keyframes pop {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .tile-2 {
            background: #ff9a3c;
            color: #fff;
        }
        
        .tile-4 {
            background: #ff6f3c;
            color: #fff;
        }
        
        .tile-8 {
            background: #ffc93c;
            color: #fff;
        }
        
        .tile-16 {
            background: #f07b3f;
            color: #fff;
        }
        
        .tile-32 {
            background: #ea5455;
            color: #fff;
        }
        
        .tile-64 {
            background: #d72323;
            color: #fff;
        }
        
        .tile-128 {
            background: #6a2c70;
            color: #fff;
            font-size: 1.8rem;
        }
        
        .tile-256 {
            background: #b83b5e;
            color: #fff;
            font-size: 1.8rem;
            box-shadow: 0 0 20px rgba(184, 59, 94, 0.5);
        }
        
        .tile-512 {
            background: #ff5c8d;
            color: #fff;
            font-size: 1.8rem;
            box-shadow: 0 0 20px rgba(255, 92, 141, 0.5);
        }
        
        .tile-1024 {
            background: #c70d3a;
            color: #fff;
            font-size: 1.5rem;
            box-shadow: 0 0 20px rgba(199, 13, 58, 0.5);
        }
        
        .tile-2048 {
            background: linear-gradient(135deg, #ffd166 0%, #ff9a3c 100%);
            color: #fff;
            font-size: 1.5rem;
            box-shadow: 0 0 30px rgba(255, 209, 102, 0.7);
        }
        
        .game-message {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
            backdrop-filter: blur(5px);
        }
        
        .game-message.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .game-message p {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
        }
        
        .btn {
            background: #ffd166;
            color: #1a1a2e;
            border: none;
            border-radius: 4px;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-out;
        }
        
        .btn:hover {
            background: #ffc93c;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 209, 102, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .restart-button {
            margin-top: 20px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .instructions {
            margin-top: 30px;
            text-align: center;
            color: #b8c2cc;
            max-width: 500px;
        }
        
        .instructions p {
            margin-bottom: 10px;
        }
        
        @media screen and (max-width: 520px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .score-box {
                min-width: 80px;
                padding: 8px 12px;
            }
            
            .score-value {
                font-size: 1.2rem;
            }
            
            .tile {
                font-size: 1.5rem;
            }
            
            .tile-128, .tile-256, .tile-512 {
                font-size: 1.3rem;
            }
            
            .tile-1024, .tile-2048 {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2048</h1>
            <div class="scores-container">
                <div class="score-box">
                    <div class="score-title">分数</div>
                    <div class="score-value" id="score">0</div>
                </div>
                <div class="score-box">
                    <div class="score-title">最佳</div>
                    <div class="score-value" id="best-score">0</div>
                </div>
            </div>
        </header>
        
        <div class="game-intro">
            <p>合并相同数字的方块，尝试获得2048方块！</p>
        </div>
        
        <div class="game-container">
            <div class="grid-container">
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            </div>
            <div class="tile-container" id="tile-container">
                <!-- 方块将由JavaScript生成 -->
            </div>
            <div class="game-message" id="game-message">
                <p id="message-text"></p>
                <button class="btn" id="retry-button">再玩一次</button>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn" id="restart-button">重新开始</button>
            <button class="btn" id="undo-button">撤销</button>
        </div>
        
        <div class="instructions">
            <p>使用键盘 <strong>箭头键</strong> 或 <strong>WASD</strong> 移动方块</p>
            <p>在移动设备上可以使用 <strong>滑动手势</strong> 移动方块</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 游戏配置
            const GRID_SIZE = 4;
            
            // 游戏状态
            let grid = [];
            let score = 0;
            let bestScore = parseInt(localStorage.getItem('bestScore')) || 0;
            let gameOver = false;
            let gameWon = false;
            let moved = false;
            let moveHistory = [];
            
            // DOM 元素
            const gridContainer = document.querySelector('.grid-container');
            const tileContainer = document.getElementById('tile-container');
            const scoreDisplay = document.getElementById('score');
            const bestScoreDisplay = document.getElementById('best-score');
            const gameMessage = document.getElementById('game-message');
            const messageText = document.getElementById('message-text');
            const retryButton = document.getElementById('retry-button');
            const restartButton = document.getElementById('restart-button');
            const undoButton = document.getElementById('undo-button');
            
            // 计算单元格大小和间隙
            function calculateCellSize() {
                const gridWidth = gridContainer.offsetWidth;
                const gridPadding = 10; // 网格容器的padding
                const gridGap = 10; // 网格间隙
                
                // 计算每个单元格的大小
                const cellSize = (gridWidth - gridPadding * 2 - gridGap * 3) / 4;
                return { cellSize, gridGap };
            }
            
            // 初始化游戏
            function initGame() {
                createCells();
                setupInput();
                addStartTiles();
                updateScore();
                
                // 更新最佳分数显示
                bestScoreDisplay.textContent = bestScore;
            }
            
            // 创建单元格数据结构
            function createCells() {
                grid = [];
                for (let i = 0; i < GRID_SIZE; i++) {
                    grid[i] = [];
                    for (let j = 0; j < GRID_SIZE; j++) {
                        grid[i][j] = null;
                    }
                }
            }
            
            // 添加初始方块
            function addStartTiles() {
                for (let i = 0; i < 2; i++) {
                    addRandomTile();
                }
            }
            
            // 随机添加方块
            function addRandomTile() {
                const emptyCells = [];
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (grid[i][j] === null) {
                            emptyCells.push({x: i, y: j});
                        }
                    }
                }
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    createTile(randomCell.x, randomCell.y, value);
                }
            }
            
            // 创建方块DOM元素
            function createTile(x, y, value) {
                const tile = document.createElement('div');
                tile.classList.add('tile', `tile-${value}`, 'tile-new');
                tile.textContent = value;
                
                // 设置位置
                updateTilePosition(tile, x, y);
                
                // 添加到网格
                grid[x][y] = {
                    value: value,
                    element: tile,
                    x: x,
                    y: y,
                    merged: false
                };
                
                tileContainer.appendChild(tile);
                
                // 移除新建动画类
                setTimeout(() => {
                    tile.classList.remove('tile-new');
                }, 200);
            }
            
            // 更新方块位置
            function updateTilePosition(tile, x, y) {
                const { cellSize, gridGap } = calculateCellSize();
                const posX = y * (cellSize + gridGap) + 'px';
                const posY = x * (cellSize + gridGap) + 'px';
                
                tile.style.transform = `translate(${posX}, ${posY})`;
            }
            
            // 设置输入控制
            function setupInput() {
                window.addEventListener('keydown', handleKeyDown);
                
                // 触摸事件处理
                let touchStartX, touchStartY;
                let touchEndX, touchEndY;
                
                document.addEventListener('touchstart', function(event) {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                }, false);
                
                document.addEventListener('touchend', function(event) {
                    touchEndX = event.changedTouches[0].clientX;
                    touchEndY = event.changedTouches[0].clientY;
                    handleSwipe();
                }, false);
                
                // 按钮事件
                retryButton.addEventListener('click', restartGame);
                restartButton.addEventListener('click', restartGame);
                undoButton.addEventListener('click', undoMove);
            }
            
            // 处理键盘输入
            function handleKeyDown(e) {
                if (gameOver) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        e.preventDefault();
                        moveTiles('up');
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        e.preventDefault();
                        moveTiles('down');
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        e.preventDefault();
                        moveTiles('left');
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        e.preventDefault();
                        moveTiles('right');
                        break;
                }
            }
            
            // 处理滑动手势
            function handleSwipe() {
                if (gameOver) return;
                
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);
                
                if (Math.max(absDx, absDy) > 10) { // 最小滑动距离
                    if (absDx > absDy) {
                        // 水平滑动
                        if (dx > 0) {
                            moveTiles('right');
                        } else {
                            moveTiles('left');
                        }
                    } else {
                        // 垂直滑动
                        if (dy > 0) {
                            moveTiles('down');
                        } else {
                            moveTiles('up');
                        }
                    }
                }
            }
            
            // 移动方块
            function moveTiles(direction) {
                // 保存移动前的状态用于撤销
                saveState();
                
                // 重置所有方块的合并状态
                resetMergedFlags();
                
                moved = false;
                
                // 根据方向处理移动
                switch(direction) {
                    case 'up':
                        for (let y = 0; y < GRID_SIZE; y++) {
                            for (let x = 1; x < GRID_SIZE; x++) {
                                if (grid[x][y] !== null) {
                                    moveTile(x, y, -1, 0);
                                }
                            }
                        }
                        break;
                    case 'down':
                        for (let y = 0; y < GRID_SIZE; y++) {
                            for (let x = GRID_SIZE - 2; x >= 0; x--) {
                                if (grid[x][y] !== null) {
                                    moveTile(x, y, 1, 0);
                                }
                            }
                        }
                        break;
                    case 'left':
                        for (let x = 0; x < GRID_SIZE; x++) {
                            for (let y = 1; y < GRID_SIZE; y++) {
                                if (grid[x][y] !== null) {
                                    moveTile(x, y, 0, -1);
                                }
                            }
                        }
                        break;
                    case 'right':
                        for (let x = 0; x < GRID_SIZE; x++) {
                            for (let y = GRID_SIZE - 2; y >= 0; y--) {
                                if (grid[x][y] !== null) {
                                    moveTile(x, y, 0, 1);
                                }
                            }
                        }
                        break;
                }
                
                // 如果有移动，添加新方块并检查游戏状态
                if (moved) {
                    setTimeout(() => {
                        addRandomTile();
                        checkGameState();
                    }, 150);
                }
            }
            
            // 重置所有方块的合并状态
            function resetMergedFlags() {
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (grid[i][j] !== null) {
                            grid[i][j].merged = false;
                        }
                    }
                }
            }
            
            // 移动单个方块
            function moveTile(x, y, dx, dy) {
                const tile = grid[x][y];
                let newX = x;
                let newY = y;
                
                // 先移动到尽可能远的位置
                while (
                    newX + dx >= 0 && newX + dx < GRID_SIZE &&
                    newY + dy >= 0 && newY + dy < GRID_SIZE &&
                    grid[newX + dx][newY + dy] === null
                ) {
                    newX += dx;
                    newY += dy;
                    moved = true;
                }
                
                // 检查是否可以合并
                if (
                    newX + dx >= 0 && newX + dx < GRID_SIZE &&
                    newY + dy >= 0 && newY + dy < GRID_SIZE &&
                    grid[newX + dx][newY + dy] !== null &&
                    grid[newX + dx][newY + dy].value === tile.value &&
                    !grid[newX + dx][newY + dy].merged
                ) {
                    // 合并方块
                    const targetTile = grid[newX + dx][newY + dy];
                    targetTile.value *= 2;
                    targetTile.merged = true;
                    targetTile.element.textContent = targetTile.value;
                    targetTile.element.classList.add('tile-merged');
                    targetTile.element.classList.remove(`tile-${tile.value}`);
                    targetTile.element.classList.add(`tile-${targetTile.value}`);
                    
                    // 更新分数
                    score += targetTile.value;
                    
                    // 移除原方块
                    tile.element.remove();
                    grid[x][y] = null;
                    
                    moved = true;
                } else if (newX !== x || newY !== y) {
                    // 移动方块到新位置
                    grid[newX][newY] = tile;
                    grid[x][y] = null;
                    
                    // 更新DOM位置
                    updateTilePosition(tile.element, newX, newY);
                    
                    tile.x = newX;
                    tile.y = newY;
                }
            }
            
            // 保存当前状态用于撤销
            function saveState() {
                const state = {
                    grid: JSON.parse(JSON.stringify(grid)),
                    score: score
                };
                
                // 转换grid数据以便存储
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (state.grid[i][j] !== null) {
                            // 移除对DOM元素的引用
                            state.grid[i][j] = {
                                value: state.grid[i][j].value,
                                x: state.grid[i][j].x,
                                y: state.grid[i][j].y
                            };
                        }
                    }
                }
                
                moveHistory.push(state);
                
                // 只保留最近5次移动历史
                if (moveHistory.length > 5) {
                    moveHistory.shift();
                }
            }
            
            // 撤销上一步移动
            function undoMove() {
                if (moveHistory.length === 0 || gameOver) return;
                
                const state = moveHistory.pop();
                
                // 清除当前网格
                clearGrid();
                
                // 恢复状态
                score = state.score;
                updateScore();
                
                // 恢复方块
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (state.grid[i][j] !== null) {
                            createTile(i, j, state.grid[i][j].value);
                        }
                    }
                }
                
                // 重置游戏状态
                gameOver = false;
                gameWon = false;
                gameMessage.classList.remove('active');
            }
            
            // 清除网格
            function clearGrid() {
                tileContainer.innerHTML = '';
                createCells();
            }
            
            // 检查游戏状态
            function checkGameState() {
                // 检查是否获胜
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (grid[i][j] !== null && grid[i][j].value === 2048 && !gameWon) {
                            gameWon = true;
                            showMessage('你赢了！', false);
                        }
                    }
                }
                
                // 检查是否还有空单元格
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (grid[i][j] === null) {
                            return; // 还有空位，游戏继续
                        }
                    }
                }
                
                // 检查是否还有可合并的相邻方块
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        const tile = grid[i][j];
                        
                        // 检查右侧
                        if (j < GRID_SIZE - 1 && grid[i][j+1] !== null && grid[i][j+1].value === tile.value) {
                            return; // 可以向右合并
                        }
                        
                        // 检查下方
                        if (i < GRID_SIZE - 1 && grid[i+1][j] !== null && grid[i+1][j].value === tile.value) {
                            return; // 可以向下合并
                        }
                    }
                }
                
                // 没有空位且无法合并，游戏结束
                gameOver = true;
                showMessage('游戏结束！', true);
            }
            
            // 显示游戏消息
            function showMessage(text, isGameOver) {
                messageText.textContent = text;
                gameMessage.classList.add('active');
                
                if (isGameOver) {
                    retryButton.style.display = 'block';
                } else {
                    retryButton.style.display = 'block';
                }
            }
            
            // 更新分数显示
            function updateScore() {
                scoreDisplay.textContent = score;
                
                // 更新最佳分数
                if (score > bestScore) {
                    bestScore = score;
                    bestScoreDisplay.textContent = bestScore;
                    localStorage.setItem('bestScore', bestScore);
                }
            }
            
            // 重新开始游戏
            function restartGame() {
                // 重置状态
                score = 0;
                gameOver = false;
                gameWon = false;
                moveHistory = [];
                
                // 更新UI
                updateScore();
                gameMessage.classList.remove('active');
                
                // 清除并重新初始化网格
                clearGrid();
                addStartTiles();
            }
            
            // 初始化游戏
            initGame();
        });
    </script>
</body>
</html>